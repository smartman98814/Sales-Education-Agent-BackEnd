pipeline {
  agent any
  environment {
    SHORTHASH = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
    APP_ENV = ''
    GKE_CLUSTER = ''
    GKE_REGION = 'asia-southeast1-a'
    GCR_REPO = 'nfa-agent-api'
  }

  stages {
    stage('Get Env') {
      steps {
        script {
          def BRANCH = env.BRANCH_NAME
          if (BRANCH == 'main') {
            APP_ENV = 'prod'
          } else if (BRANCH == 'staging') {
            APP_ENV = 'staging'
          } else {
            echo "Unsupported branch: ${BRANCH}"
            error("Unsupported branch: ${BRANCH}")
          }
          GKE_CLUSTER = (APP_ENV == 'prod') ? "pivotal-${APP_ENV}" : 'allinone-staging'
        }
      }
    }

    stage('Authenticate with GCP') {
      steps {
        script {
          withCredentials([
            file(credentialsId: 'gcp-github-ci-cd-key', variable: 'GOOGLE_APPLICATION_CREDENTIALS'),
            string(credentialsId: 'gcp-project-name', variable: 'GCP_PROJECT')
          ]) {
            sh """
              gcloud auth activate-service-account --key-file=$GOOGLE_APPLICATION_CREDENTIALS
              gcloud config set project $GCP_PROJECT
              gcloud container clusters get-credentials $GKE_CLUSTER --zone $GKE_REGION
            """
          }
        }
      }
    }

    stage('Build & Push Image to GCR') {
      steps {
        catchError(buildResult: 'FAILURE') {
          withCredentials([string(credentialsId: 'gcp-project-name', variable: 'GCP_PROJECT')]) {
            sh """
              docker build --platform=linux/amd64 -t nfa-agent-api:$SHORTHASH -f deployment/Dockerfile .
              docker tag nfa-agent-api:$SHORTHASH gcr.io/$GCP_PROJECT/$GCR_REPO:$SHORTHASH
              gcloud auth configure-docker
              docker push gcr.io/$GCP_PROJECT/$GCR_REPO:$SHORTHASH
            """
          }
        }
      }
    }

    stage('Deploy to GKE') {
      steps {
        catchError(buildResult: 'FAILURE') {
          withCredentials([
            string(credentialsId: 'gcp-project-name', variable: 'GCP_PROJECT'),
            string(credentialsId: "nfa-agent-webhook-password-${APP_ENV}", variable: 'WEBHOOK_PASSWORD'),
            string(credentialsId: "nfa-agent-api-replicas-${APP_ENV}", variable: 'API_REPLICAS')
          ]) {
            sh """
              cat deployment/${APP_ENV}/deployment.yaml | sed -e 's|{{BASE_REPOSITORY}}|gcr.io/${GCP_PROJECT}|g' -e 's|{{SHORTHASH}}|${SHORTHASH}|g' -e 's|{{APP_ENV}}|${APP_ENV}|g' -e 's|__API_REPLICAS__|${API_REPLICAS}|g' | kubectl apply -f -
            """
          }
        }
      }
    }

    stage('Notify Slack') {
      steps {
        script {
          def slackChannel = '#dev-feed'
          def slackMessage
          def prettyAppEnv = (APP_ENV == 'prod') ? 'PRODUCTION' : (APP_ENV == 'staging') ? 'STAGING' : (APP_ENV == 'v2-staging') ? 'V2 STAGING' : 'Unknown'

          if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
            slackMessage = "<!channel> NFA Agent ${prettyAppEnv} API is successfully deployed.\n${env.BUILD_URL}"
          } else {
            slackMessage = "<!channel> NFA Agent ${prettyAppEnv} API deployment failed.\n${env.BUILD_URL}"
          }

          def attachments = [
            [
              text: slackMessage,
              fallback: slackMessage,
              color: currentBuild.resultIsBetterOrEqualTo('SUCCESS') ? 'good' : 'danger'
            ]
          ]

          slackSend(channel: slackChannel, attachments: attachments)
        }
      }
    }
  }

  post {
    failure {
      script {
        def attachments = [
          [
            text: "<!channel> NFA Agent ${prettyAppEnv} API deployment failed.\n${env.BUILD_URL}",
            fallback: "<!channel> NFA Agent ${prettyAppEnv} API deployment failed.\n${env.BUILD_URL}",
            color: 'danger'
          ]
        ]
        slackSend(channel: slackChannel, attachments: attachments)
      }
    }
  }
}
